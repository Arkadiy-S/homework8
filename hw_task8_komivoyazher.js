
// ДЗ  Задача 7. 
/* Задача комивояжера. Пусть дан граф, причем каждому его ребру сопоставлен вес (взвешенный граф). 
Требуется найти путь между двумя заданными вершинами с наименьшим весом.
На вход будет подан массив ребер графа [[0, 3, 5], [1, 3, 11], [2, 3, 56], [4, 3, 77], [5, 4, 89]] Третий параметр  - вес ребра.
У структуры данных граф должна быть функция, принимающая два параметра (nodeStart, nodeEnd). 
Данная функция должна вывести кратчайший путь из nodeStart в nodeEnd.

*/
 

"use strict";

// 1. объявление объектов *****************************************************************************************
// Спецификация - обозначение узлов по номерам

// описание графа. В нем - узлы и методы заполнения и обхода 
class Graf {
    constructor() {
        this.nodes = [];
    }
    
    // Методы графа
    //-------- метод - добавление одного узла
    addEdges(value, lines = []) {
      this.nodes.push({
        value: value,
        d: Infinity,
        shortestPathNode: 0,
        visited: false,
        lines: lines.slice(0) // копируем массив по значениям элементов
    });
    }
    
        //-------maxNodeNum - Определение номера последней вершины по списку ребер edges 
        maxNodeNum (edges) {
        let max = 0;
        let i = 0;

        for (i = 0; i < edges.length; i++) {
            if (max < Math.max.apply(null, edges[0], edges[1])) max = Math.max.apply(null, edges[0], edges[1]);
        }
        return max;
        }
        // end maxNodeNum

    //-------fillGraf метод - добавление всех узлов графа со списком смежных узлов из входного массива ребер
    fillGraf(edges) {
      let i = 0;
      let j = 0;
      
      let n = this.maxNodeNum(edges); //номер последнего узла
      

      for (i = 0; i <= n; i++) {  // в цикле до последнего узла формируем узлы из из входного массива ребер
      
        // объявление  массива для временного хранения номера смежгого узла и веса ребра:
        let linesTmp = [];
       
        for (j = 0; j < edges.length; j++) {  // цикл по числу элементов входного массива дуг
          // заносим номера смежных узлов для текущего i-го узла, перебирая ребра из входного массива, через промежуточный массив linesTmp 
          // и функцию addEdges - добавления узла:
          let linesTmp3to2 = [];
          if (edges [j][0] == i) {
            // из элемента массива ребер вида [№ текущего узла, № смежного узла, вес] делаем [№ смежного узла, вес]
            linesTmp3to2 = edges[j].slice(0);
            linesTmp3to2.splice(0,1);
            linesTmp.push(linesTmp3to2); // и формируем массив смежных узлов и их весов для текущего
          }
          if (edges [j][1] == i) {
            // из элемента массива ребер вида [ № смежного узла, № текущего узла, вес] делаем [индекс 0 - № смежного узла, инд.1 - вес]
            linesTmp3to2 = edges[j].slice(0); 
            linesTmp3to2.splice(1,1);
            linesTmp.push(linesTmp3to2); // и формируем массив смежных узлов и их весов для текущего
          }
        } 
  
      this.addEdges(i, linesTmp); // добавляем узел в структуру графа
      }
    }
    //fillGraf end
    
    // ----- resetNodes - восстановление состояния графа
    resetNodes () {
    let i = 0;
    let n = this.maxNodeNum(edges); //номер последнего узла
    for (i = 0; i <= n; i++) {      
    graf.nodes[i].visited = false;
    }
    }
    // end resetNodes


    /*------- shortestPath - Алгоритм Дейкстры - поиска кратчайшего пути

    Шаг 1. 1.Всем узлам графа присваивается значение не посещенный  и d(node) - длина кратчайшего пути = Infinity 
           (выполняется при инициализации графа (и заполнении массивом ребер) или с пом. метода восстановления состояния графа resetNodes). 
           2.Стартовый заносится в очередь и для стартового узла d(node)=0)(это когда очередь еще пуста). На вход метода подается узел из очереди
           (очередь строится так, что это узел с наименьшим d(node) для каждого случая, в самом начале этим узлом будет стартовый).
    Шаг 2. Перебираются все смежные для него узлы, в порядке возрастания веса ребра,
           т.е сначала выбирается не посещенный узел с наименьшим весом ребра, затем с большим и т.д.;
           для него заново определяется d(node):  если [d(node)текущего узла +  (вес ребра)] < d(node) смеж.узла  , то для d(node) присваивается эта сумма; 
           и его номер заносится в очередь для посещения.
           После завершения перебора входной-текущий узел удаляется из очереди. Очередь сдвигается и следующий за ним становится первым в очереди.
    Шаг 3. Повторяется шаг 2 до тех пор, пока очередь не пуста
    */ 
    shortestPath(k,nodeEnd,nodeStart, next = [])  {
     
      let i = 0;
      let j = 0;
      let p = 0;
     
      let visitedTmp = []; // вспомогат. массив для сортировки по весу ребра, запоминает найденные с минимальным весом смежные узлы (номер), чтобы их пропускать

      if (next.length == 0) { //шаг 1.2 инициализация - самый первый стартовый узел (его номер) заносится в очередь для посещения
        nodeStart = k; // чб сохранить nodeStart в рекурсиях
        next.push(k); 
        this.nodes[k].d = 0; // инициализация - самый первый стартовый узел  d = 0
      }

      for (let i=0; i < graf.nodes[k].lines.length; i++) { //сортировка циклом в цикле, смежные узлы выбираются по очереди - перебираются все смежные узлы для K узла, 
        // начиная с мин. весом ребра, так что d - дистанция для каждого дб пересчитана
        let minEdge = Infinity; //запоминает в переборе мин вес ребра
        let minEdgeNode;//запоминает в переборе смежный узел с мин весом ребра
        

        for (let i1=0; i1 < graf.nodes[k].lines.length; i1++) { //подцикл поиска мин. ребра из оставшихся - перебираются все смежные узлы для K - узла, находится первый с мин. весом ребра,
          // обрабатывается и запоминается, т.чтобы в след. раз  к нему не обращаться:
          j = graf.nodes[k].lines[i1][0]; // переменные для упрощения записи j - смежный узел (номер) для K - узла в i-й итерации
          if (graf.nodes[j].visited == true) continue; //если смеж.узел помечен как посещенный, то он пропускается 
          if (visitedTmp.indexOf(j)!= -1) continue; //если этот смежный узел с мин весом ребра уже пересчитан, то его пропускаем
           
          p = graf.nodes[k].lines[i1][1]; // вес ребра от K-узла к смежному j // переменная для упрощения записи
          if (minEdge > p) { // находим мин вес ребра от K-узла к смежному j в итерациях
            minEdge = p; 
            minEdgeNode = j; // и запоминаем этот смежный узел  с мин весом ребра 
          }
        } 
        if (minEdge == Infinity) continue; // если нет непосещенных смежных узлов выход из внешнего цикла, например, для тупика
        visitedTmp.push(minEdgeNode); // смежный узел с мин весом ребра найден в 1й итерации и запомнен, чтобы в след. раз к нему не обращаться,  
        /* обработка этого смеж. узла:
           для него заново определяется d(node):  если [d(node)текущего узла +  (вес ребра)] <  d(node) смеж. узла, то для d(node) присваивается эта сумма; 
           и его номер заносится в очередь для посещения. Также для восстановления кратчайшего пути запоминается текущий узел, из которого получилось d мин  
        */   
            if (graf.nodes[minEdgeNode].visited == false) {
            if (graf.nodes[minEdgeNode].d > (graf.nodes[k].d + minEdge)) graf.nodes[minEdgeNode].d = graf.nodes[k].d + minEdge; // пересчет
            next.push(minEdgeNode); // номер смежного узла  с мин весом ребра  заносится в очередь для посещения (в конец массива) 
            graf.nodes[minEdgeNode].shortestPathNode = k; // для восстановления пути запоминаем номер текущего узла для этого смежного  с мин d, т.е. от которого 
            // кратчайший путь к этому смежному узлу 
            }
      }

      // После завершения перебора входной-текущий узел помечается как посещенный и удаляется из очереди открытых дл посещения узлов. 
      graf.nodes[k].visited = true;
      next.shift(); // обработанный текущий узел выходит из очереди для посещения (из начала массива), 
      if (next.length == 0) {  // вывод пути и выход из функции если очередь закончилась
        console.log ("все узлы графа обработаны, кратчайший путь от узла " + nodeStart + " до " + nodeEnd);
        console.log ("Узел Дистанция");
        
        for (i = nodeEnd; i != nodeStart; i = graf.nodes[i].shortestPathNode) {
          console.log (i + "    " +  graf.nodes[i].d);
        }
        console.log (i + "    " + graf.nodes[i].d);  
        return;  // выход из функции
      }  
      else { //или повторяется шаг 2 до тех пор, пока очередь не пуста 
        k = next[0];
        this.shortestPath(k, nodeEnd, nodeStart, next); // рекурсивно вызываем функцию shortestPath
      }
    } 
    // end shortestPath  
}
//end Graf

// 2. работа с графом *****************************************************************************************

//let edges = [[1, 2, 7], [1, 3, 9], [1, 6, 14], [4, 2, 15], [3, 4, 11], [3, 6, 2], [6, 5 , 9], [4, 5, 6]]; //отладка граф из википедии
let edges = [[0, 3, 5], [1, 3, 11], [2, 3, 56], [4, 3, 77], [5, 4, 89]]; // по условию

let graf = new Graf();
graf.fillGraf(edges);


graf.shortestPath(0, 5);

console.log('end');




